{"ast":null,"code":"import { getCurrentInstance, computed, shallowReadonly, normalizeClass, normalizeStyle } from \"vue\";\nimport { u as useComponentConfigProps } from \"../component-config/utils/use-component-config-props-b8569aeb.mjs\";\nimport { o as omit } from \"../../../vendor-2b2dbafd.mjs\";\nconst toCamelCase = str => str.replace(/-([a-z])/g, g => g[1].toUpperCase());\nconst findCamelCased = (obj, key) => {\n  const found = Object.keys(obj).find(k => toCamelCase(k) === key);\n  return found && obj[found];\n};\nconst createPropsWithCustomConfig = (instance, propsFromConfig) => {\n  const instanceProps = instance.props;\n  return new Proxy(instanceProps, {\n    get: (target, key) => {\n      var _a;\n      if (typeof key !== \"string\") {\n        return target[key];\n      }\n      const incomingProps = instance.vnode.props || {};\n      const originalProp = target[key];\n      const propFromConfig = (_a = propsFromConfig.value) == null ? void 0 : _a[key];\n      const incomingProp = findCamelCased(incomingProps, key);\n      if (incomingProp !== void 0) {\n        return originalProp;\n      }\n      if (propFromConfig !== void 0) {\n        return propFromConfig;\n      }\n      return originalProp;\n    }\n  });\n};\nconst createAttrsWithCustomConfig = (instance, propsFromConfig) => {\n  const instanceAttrs = instance.attrs;\n  return new Proxy(instanceAttrs, {\n    get: (target, key) => {\n      var _a;\n      if (typeof key !== \"string\") {\n        return target[key];\n      }\n      if (key === \"class\") {\n        return (normalizeClass(propsFromConfig.value.class) + \" \" + instanceAttrs.class).trim();\n      }\n      if (key === \"style\") {\n        return normalizeStyle([propsFromConfig.value.style, instanceAttrs.style]);\n      }\n      const attrFromConfig = (_a = propsFromConfig.value) == null ? void 0 : _a[key];\n      if (attrFromConfig !== void 0) {\n        return attrFromConfig;\n      }\n      return target[key];\n    },\n    ownKeys(target) {\n      return [... /* @__PURE__ */new Set([...Object.keys(instanceAttrs), ...Object.keys(propsFromConfig.value)])];\n    },\n    getOwnPropertyDescriptor(target, key) {\n      return Reflect.getOwnPropertyDescriptor(propsFromConfig.value, key) ?? Reflect.getOwnPropertyDescriptor(instanceAttrs, key);\n    }\n  });\n};\nconst createProxyComponent = component => {\n  const customSetup = (originalProps, ctx) => {\n    var _a;\n    const instance = getCurrentInstance();\n    const propsFromConfig = useComponentConfigProps(component, originalProps);\n    const attrsFromConfig = computed(() => {\n      return omit(propsFromConfig.value, Object.keys(originalProps));\n    });\n    const props = createPropsWithCustomConfig(instance, propsFromConfig);\n    const attrs = createAttrsWithCustomConfig(instance, attrsFromConfig);\n    instance.props = props;\n    instance.attrs = attrs;\n    return (_a = component.setup) == null ? void 0 : _a.call(component, shallowReadonly(props), {\n      ...ctx,\n      attrs\n    });\n  };\n  return new Proxy(component, {\n    get(target, key) {\n      if (key === \"setup\") {\n        return customSetup;\n      }\n      return target[key];\n    }\n  });\n};\nexport { createProxyComponent as c };","map":{"version":3,"names":["toCamelCase","str","replace","g","toUpperCase","findCamelCased","obj","key","found","Object","keys","find","k","createPropsWithCustomConfig","instance","propsFromConfig","instanceProps","props","Proxy","get","target","incomingProps","vnode","originalProp","propFromConfig","_a","value","incomingProp","createAttrsWithCustomConfig","instanceAttrs","attrs","normalizeClass","class","trim","normalizeStyle","style","attrFromConfig","ownKeys","Set","getOwnPropertyDescriptor","Reflect","createProxyComponent","component","customSetup","originalProps","ctx","getCurrentInstance","useComponentConfigProps","attrsFromConfig","computed","omit","setup","call","shallowReadonly"],"sources":["../../../../../src/services/config-transport/createProxyComponent.ts"],"sourcesContent":["import { getCurrentInstance, ComponentInternalInstance, DefineComponent, SetupContext, Ref, shallowReadonly, normalizeClass, normalizeStyle, computed } from 'vue'\nimport { useComponentConfigProps } from '../component-config/utils/use-component-config-props'\nimport omit from 'lodash/omit'\n\n/** Compiled and reactive props. By default they passed to setup fn */\ntype Props = Record<string, unknown>;\n/** Raw props */\ntype RawProps = Record<string, unknown>;\n\nconst toCamelCase = (str: string) => str.replace(/-([a-z])/g, (g) => g[1].toUpperCase())\n\nconst findCamelCased = (obj: Record<string, unknown>, key: string) => {\n  const found = Object.keys(obj).find((k) => toCamelCase(k) === key)\n  return found && obj[found]\n}\n\n/**\n * @param propsFromConfig Ref of custom props. Required to be ref so vue can rerender component on custom props change.\n * @returns new props object, where some props replaced with props from config.\n */\nconst createPropsWithCustomConfig = (instance: ComponentInternalInstance, propsFromConfig: Ref<Props>) => {\n  /**\n   * Reactive and compiled props. Compiled props considering default value, Boolean transformation etc.\n   * It is a default props that passed to setup function.\n   */\n  const instanceProps: Props = instance.props\n\n  return new Proxy(instanceProps, {\n    get: (target, key: string) => {\n      if (typeof key !== 'string') { return target[key] }\n\n      /**\n       * Props passed to VNode. Not compiled at all and not reactive.\n       * VNode props contained only props passed from parent.\n       */\n      const incomingProps: RawProps = instance.vnode.props || {}\n\n      /**\n       * Make sure to access both original and from config prop in get.\n       * Since instanceProps and propsFromConfig both are reactive, we need to know that both of\n       * this objects are dependency of effect where proxy is used.\n       * If original prop will not be accessed vue will not track reactivity for original props object.\n       */\n      const originalProp = target[key]\n      const propFromConfig = propsFromConfig.value?.[key]\n      const incomingProp = findCamelCased(incomingProps, key)\n\n      if (incomingProp !== undefined) {\n        return originalProp\n      }\n\n      // Return prop from config only if user didn't pass props manually\n      if (propFromConfig !== undefined) {\n        return propFromConfig\n      }\n\n      return originalProp\n    },\n  })\n}\n\nconst mergeStyles = (style1: unknown, style2: unknown) => {\n  if (!style1) { return style2 }\n  if (!style2) { return style1 }\n\n  if (typeof style1 === 'string' && typeof style2 === 'string') {\n    return style1 + style2\n  }\n\n  if (Array.isArray(style1) && Array.isArray(style2)) {\n    return [...(style1 || []), ...(style2 || [])]\n  }\n\n  if (typeof style1 === 'object' && typeof style2 === 'object') {\n    return { ...style1, ...style2 }\n  }\n\n  console.warn('[Vuestic UI] Cannot merge styles', style1, style2)\n  throw new Error('[Vuestic UI] Cannot merge styles. It is internal Vuestic error, please open issue on github')\n}\n\nconst createAttrsWithCustomConfig = (instance: ComponentInternalInstance, propsFromConfig: Ref<Props>) => {\n  // Instance.attrs will be patched later, so we save original object here to prevent recursion\n  const instanceAttrs = instance.attrs\n\n  return new Proxy(instanceAttrs, {\n    get: (target, key: string) => {\n      if (typeof key !== 'string') { return target[key] }\n\n      if (key === 'class') {\n        return (normalizeClass(propsFromConfig.value.class) + ' ' + instanceAttrs.class).trim()\n      }\n\n      if (key === 'style') {\n        return normalizeStyle([propsFromConfig.value.style, instanceAttrs.style])\n      }\n\n      const attrFromConfig = propsFromConfig.value?.[key]\n\n      if (attrFromConfig !== undefined) {\n        return attrFromConfig\n      }\n\n      return target[key]\n    },\n    ownKeys (target) {\n      // TODO: Optimize\n      return [...new Set([...Object.keys(instanceAttrs), ...Object.keys(propsFromConfig.value)])]\n    },\n    getOwnPropertyDescriptor (target, key) {\n      return Reflect.getOwnPropertyDescriptor(propsFromConfig.value, key) ?? Reflect.getOwnPropertyDescriptor(instanceAttrs, key)\n    },\n  })\n}\n\nexport const createProxyComponent = <T extends DefineComponent>(component: T) => {\n  const customSetup = (originalProps: Props, ctx: SetupContext) => {\n    const instance = getCurrentInstance()! // Not null during setup call\n    const propsFromConfig = useComponentConfigProps(component, originalProps)\n    const attrsFromConfig = computed(() => {\n      return omit(propsFromConfig.value, Object.keys(originalProps))\n    })\n\n    const props = createPropsWithCustomConfig(instance, propsFromConfig)\n    const attrs = createAttrsWithCustomConfig(instance, attrsFromConfig)\n\n    /**\n     * Patch instance props with Proxy.\n     * This will change props object during render and in Devtools.\n     */\n    instance.props = props\n    instance.attrs = attrs\n\n    return component.setup?.(shallowReadonly(props), {\n      ...ctx,\n      attrs,\n    })\n  }\n\n  return new Proxy(component, {\n    get (target, key: any) {\n      if (key === 'setup') { return customSetup }\n\n      return target[key]\n    },\n  })\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}