{"ast":null,"code":"import { _ as _sfc_main } from \"./VaSelect.vue_vue_type_script_lang-75e00f56.mjs\";\nimport { resolveComponent, openBlock, createBlock, mergeProps, withCtx, createVNode, withKeys, withModifiers, createSlots, createCommentVNode, renderList, renderSlot, normalizeProps, guardReactiveProps, normalizeStyle } from \"vue\";\nimport { _ as _export_sfc } from \"../../../plugin-vue_export-helper-cc2b3d55.mjs\";\nconst VaSelect_vue_vue_type_style_index_0_lang = \"\";\nfunction _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {\n  const _component_va_icon = resolveComponent(\"va-icon\");\n  const _component_va_select_content = resolveComponent(\"va-select-content\");\n  const _component_va_input_wrapper = resolveComponent(\"va-input-wrapper\");\n  const _component_va_select_option_list = resolveComponent(\"va-select-option-list\");\n  const _component_va_dropdown_content = resolveComponent(\"va-dropdown-content\");\n  const _component_va_dropdown = resolveComponent(\"va-dropdown\");\n  return openBlock(), createBlock(_component_va_dropdown, mergeProps({\n    ref: \"dropdown\",\n    modelValue: _ctx.showDropdownContentComputed,\n    \"onUpdate:modelValue\": _cache[4] || (_cache[4] = $event => _ctx.showDropdownContentComputed = $event),\n    class: \"va-select va-select__dropdown va-select-dropdown\"\n  }, _ctx.dropdownPropsComputed, {\n    role: \"combobox\"\n  }), {\n    anchor: withCtx(() => [createVNode(_component_va_input_wrapper, mergeProps(_ctx.inputWrapperPropsComputed, {\n      ref: \"input\",\n      class: [\"va-select__anchor va-select-anchor__input\", _ctx.inputWrapperClassComputed],\n      \"aria-haspopup\": \"listbox\",\n      \"model-value\": _ctx.valueString,\n      readonly: true,\n      \"aria-label\": _ctx.$props.ariaLabel,\n      \"aria-controls\": _ctx.popupId,\n      \"aria-owns\": _ctx.popupId,\n      onFocus: _ctx.onInputFocus,\n      onBlur: _ctx.onInputBlur,\n      onKeydown: [withKeys(_ctx.toggleDropdown, [\"enter\"]), withKeys(withModifiers(_ctx.toggleDropdown, [\"stop\", \"prevent\"]), [\"space\"])]\n    }), createSlots({\n      icon: withCtx(() => [_ctx.showClearIcon ? (openBlock(), createBlock(_component_va_icon, mergeProps({\n        key: 0,\n        role: \"button\",\n        \"aria-label\": _ctx.tp(_ctx.$props.ariaClearLabel)\n      }, _ctx.clearIconProps, {\n        onClick: withModifiers(_ctx.reset, [\"stop\"]),\n        onKeydown: [withKeys(withModifiers(_ctx.reset, [\"stop\"]), [\"enter\"]), withKeys(withModifiers(_ctx.reset, [\"stop\"]), [\"space\"])]\n      }), null, 16, [\"aria-label\", \"onClick\", \"onKeydown\"])) : createCommentVNode(\"\", true)]),\n      appendInner: withCtx(() => [createVNode(_component_va_icon, {\n        color: _ctx.toggleIconColor,\n        name: _ctx.toggleIcon,\n        class: \"va-select__toggle-icon\",\n        role: \"button\",\n        tabindex: _ctx.openSelectButtonTabIndexComputed,\n        \"aria-expanded\": _ctx.showDropdownContentComputed\n      }, null, 8, [\"color\", \"name\", \"tabindex\", \"aria-expanded\"])]),\n      default: withCtx(({\n        ariaAttributes\n      }) => [createVNode(_component_va_select_content, mergeProps(_ctx.selectContentPropsComputed, {\n        ariaAttributes,\n        onToggleHidden: _ctx.toggleHiddenOptionsState,\n        onAutocompleteInput: _ctx.setAutocompleteValue,\n        onFocusPrev: _ctx.focusPreviousOption,\n        onFocusNext: _ctx.focusNextOption,\n        onSelectOption: _ctx.selectOrAddOption,\n        onDeleteLastSelected: _ctx.deleteLastSelected,\n        onClick: _ctx.focusAutocompleteInput\n      }), createSlots({\n        _: 2\n      }, [renderList(_ctx.$slots, (_, name) => {\n        return {\n          name,\n          fn: withCtx(slotScope => [renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(slotScope)))])\n        };\n      })]), 1040, [\"ariaAttributes\", \"onToggleHidden\", \"onAutocompleteInput\", \"onFocusPrev\", \"onFocusNext\", \"onSelectOption\", \"onDeleteLastSelected\", \"onClick\"])]),\n      _: 2\n    }, [renderList(_ctx.$slots, (_, name) => {\n      return {\n        name,\n        fn: withCtx(slotScope => [renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(slotScope)))])\n      };\n    })]), 1040, [\"class\", \"model-value\", \"aria-label\", \"aria-controls\", \"aria-owns\", \"onFocus\", \"onBlur\", \"onKeydown\"])]),\n    default: withCtx(() => [createVNode(_component_va_dropdown_content, {\n      class: \"va-select-dropdown__content\",\n      style: normalizeStyle({\n        width: _ctx.$props.width\n      }),\n      onKeydown: withKeys(_ctx.hideAndFocus, [\"esc\"]),\n      role: \"dialog\"\n    }, {\n      default: withCtx(() => [_ctx.showSearchInput ? (openBlock(), createBlock(_component_va_input_wrapper, {\n        key: 0,\n        ref: \"searchBar\",\n        class: \"va-select-dropdown__content-search-input\",\n        modelValue: _ctx.searchInput,\n        \"onUpdate:modelValue\": _cache[0] || (_cache[0] = $event => _ctx.searchInput = $event),\n        \"aria-label\": _ctx.tp(_ctx.$props.ariaSearchLabel),\n        tabindex: _ctx.tabIndexComputed,\n        placeholder: _ctx.tp(_ctx.$props.searchPlaceholderText),\n        preset: \"bordered\",\n        onKeydown: [withKeys(withModifiers(_ctx.focusPreviousOption, [\"stop\", \"prevent\"]), [\"up\"]), withKeys(withModifiers(_ctx.focusPreviousOption, [\"stop\", \"prevent\"]), [\"left\"]), withKeys(withModifiers(_ctx.focusNextOption, [\"stop\", \"prevent\"]), [\"down\"]), withKeys(withModifiers(_ctx.focusNextOption, [\"stop\", \"prevent\"]), [\"right\"]), withKeys(withModifiers(_ctx.selectOrAddOption, [\"prevent\"]), [\"enter\"])],\n        onFocus: _cache[1] || (_cache[1] = $event => _ctx.hoveredOption = null)\n      }, null, 8, [\"modelValue\", \"aria-label\", \"tabindex\", \"placeholder\", \"onKeydown\"])) : createCommentVNode(\"\", true), createVNode(_component_va_select_option_list, mergeProps({\n        ref: \"optionList\",\n        class: \"va-select-dropdown__options-wrapper\",\n        hoveredOption: _ctx.hoveredOption,\n        \"onUpdate:hoveredOption\": _cache[2] || (_cache[2] = $event => _ctx.hoveredOption = $event),\n        style: {\n          maxHeight: _ctx.$props.maxHeight\n        },\n        id: _ctx.popupId\n      }, _ctx.optionsListPropsComputed, {\n        onSelectOption: _ctx.selectHoveredOption,\n        onNoPreviousOptionToHover: _ctx.focusSearchBar,\n        onKeydown: [_cache[3] || (_cache[3] = withKeys(withModifiers($event => _ctx.searchBar && _ctx.searchBar.focus(), [\"stop\", \"prevent\"]), [\"tab\"])), _ctx.onHintedSearch],\n        onScrollBottom: _ctx.onScrollBottom\n      }), {\n        default: withCtx(slotData => [renderSlot(_ctx.$slots, \"option\", normalizeProps(guardReactiveProps(slotData || {})))]),\n        _: 3\n      }, 16, [\"hoveredOption\", \"style\", \"id\", \"onSelectOption\", \"onNoPreviousOptionToHover\", \"onKeydown\", \"onScrollBottom\"])]),\n      _: 3\n    }, 8, [\"style\", \"onKeydown\"])]),\n    _: 3\n  }, 16, [\"modelValue\"]);\n}\nconst _VaSelect = /* @__PURE__ */_export_sfc(_sfc_main, [[\"render\", _sfc_render]]);\nexport { _VaSelect as _ };\nimport '../../../VaSelect.css';","map":{"version":3,"names":["_component_va_dropdown","resolveComponent","createBlock","mergeProps","ref","modelValue","_ctx","showDropdownContentComputed","_cache","$event","class","dropdownPropsComputed","role","anchor","withCtx","createVNode","_component_va_input_wrapper","inputWrapperPropsComputed","inputWrapperClassComputed","valueString","readonly","$props","ariaLabel","popupId","onFocus","onInputFocus","onBlur","onInputBlur","onKeydown","withKeys","toggleDropdown","createSlots","icon","showClearIcon","openBlock","_component_va_icon","key","tp","ariaClearLabel","clearIconProps","onClick","withModifiers","reset","createCommentVNode","appendInner","color","toggleIconColor","name","toggleIcon","tabindex","openSelectButtonTabIndexComputed","default","ariaAttributes","_component_va_select_content","selectContentPropsComputed","onToggleHidden","toggleHiddenOptionsState","onAutocompleteInput","setAutocompleteValue","onFocusPrev","focusPreviousOption","onFocusNext","focusNextOption","onSelectOption","selectOrAddOption","onDeleteLastSelected","deleteLastSelected","focusAutocompleteInput","_","renderList","$slots","_component_va_dropdown_content","style","normalizeStyle","width","hideAndFocus","showSearchInput","searchInput","ariaSearchLabel","tabIndexComputed","placeholder","searchPlaceholderText","preset","hoveredOption","_component_va_select_option_list","maxHeight","id","optionsListPropsComputed","selectHoveredOption","onNoPreviousOptionToHover","focusSearchBar","searchBar","focus","onHintedSearch","onScrollBottom","slotData","renderSlot","normalizeProps","guardReactiveProps"],"sources":["../../../../../src/components/va-select/VaSelect.vue"],"sourcesContent":["<template>\n  <va-dropdown\n    ref=\"dropdown\"\n    v-model=\"showDropdownContentComputed\"\n    class=\"va-select va-select__dropdown va-select-dropdown\"\n    v-bind=\"dropdownPropsComputed\"\n    role=\"combobox\"\n  >\n    <template #anchor>\n      <va-input-wrapper\n        v-bind=\"inputWrapperPropsComputed\"\n        ref=\"input\"\n        class=\"va-select__anchor va-select-anchor__input\"\n        aria-haspopup=\"listbox\"\n        :class=\"inputWrapperClassComputed\"\n        :model-value=\"valueString\"\n        :readonly=\"true\"\n        :aria-label=\"$props.ariaLabel\"\n        :aria-controls=\"popupId\"\n        :aria-owns=\"popupId\"\n        @focus=\"onInputFocus\"\n        @blur=\"onInputBlur\"\n        @keydown.enter=\"toggleDropdown\"\n        @keydown.space.stop.prevent=\"toggleDropdown\"\n      >\n        <template\n          v-for=\"(_, name) in $slots\"\n          :key=\"name\"\n          v-slot:[name]=\"slotScope\"\n        >\n          <slot :name=\"name\" v-bind=\"slotScope\" />\n        </template>\n\n        <template #icon>\n          <va-icon\n            v-if=\"showClearIcon\"\n            role=\"button\"\n            :aria-label=\"tp($props.ariaClearLabel)\"\n            v-bind=\"clearIconProps\"\n            @click.stop=\"reset\"\n            @keydown.enter.stop=\"reset\"\n            @keydown.space.stop=\"reset\"\n          />\n        </template>\n\n        <template #appendInner>\n          <va-icon\n            :color=\"toggleIconColor\"\n            :name=\"toggleIcon\"\n            class=\"va-select__toggle-icon\"\n            role=\"button\"\n            :tabindex=\"openSelectButtonTabIndexComputed\"\n            :aria-expanded=\"showDropdownContentComputed\"\n          />\n        </template>\n\n        <template #default=\"{ ariaAttributes }\">\n          <va-select-content\n            v-bind=\"selectContentPropsComputed\"\n            :ariaAttributes=\"ariaAttributes\"\n            @toggle-hidden=\"toggleHiddenOptionsState\"\n            @autocomplete-input=\"setAutocompleteValue\"\n            @focus-prev=\"focusPreviousOption\"\n            @focus-next=\"focusNextOption\"\n            @select-option=\"selectOrAddOption\"\n            @delete-last-selected=\"deleteLastSelected\"\n            @click=\"focusAutocompleteInput\"\n          >\n            <template\n              v-for=\"(_, name) in $slots\"\n              :key=\"name\"\n              v-slot:[name]=\"slotScope\"\n            >\n              <slot :name=\"name\" v-bind=\"slotScope\" />\n            </template>\n          </va-select-content>\n        </template>\n      </va-input-wrapper>\n    </template>\n\n    <va-dropdown-content\n      class=\"va-select-dropdown__content\"\n      :style=\"{ width: $props.width }\"\n      @keydown.esc=\"hideAndFocus\"\n      role=\"dialog\"\n    >\n      <va-input-wrapper\n        v-if=\"showSearchInput\"\n        ref=\"searchBar\"\n        class=\"va-select-dropdown__content-search-input\"\n        v-model=\"searchInput\"\n        :aria-label=\"tp($props.ariaSearchLabel)\"\n        :tabindex=\"tabIndexComputed\"\n        :placeholder=\"tp($props.searchPlaceholderText)\"\n        preset=\"bordered\"\n        @keydown.up.stop.prevent=\"focusPreviousOption\"\n        @keydown.left.stop.prevent=\"focusPreviousOption\"\n        @keydown.down.stop.prevent=\"focusNextOption\"\n        @keydown.right.stop.prevent=\"focusNextOption\"\n        @keydown.enter.prevent=\"selectOrAddOption\"\n        @focus=\"hoveredOption = null\"\n      />\n      <va-select-option-list\n        ref=\"optionList\"\n        class=\"va-select-dropdown__options-wrapper\"\n        v-model:hoveredOption=\"hoveredOption\"\n        :style=\"{ maxHeight: $props.maxHeight }\"\n        :id=\"popupId\"\n        v-bind=\"optionsListPropsComputed\"\n        @select-option=\"selectHoveredOption\"\n        @no-previous-option-to-hover=\"focusSearchBar\"\n        @keydown.tab.stop.prevent=\"searchBar && searchBar.focus()\"\n        @keydown=\"onHintedSearch\"\n        @scroll-bottom=\"onScrollBottom\"\n        v-slot=\"slotData\"\n      >\n        <slot name=\"option\" v-bind=\"slotData || {}\" />\n      </va-select-option-list>\n    </va-dropdown-content>\n  </va-dropdown>\n</template>\n\n<script lang=\"ts\">\nimport { defineComponent, ref, shallowRef, computed, watch, nextTick, type PropType, type Ref } from 'vue'\nimport pick from 'lodash/pick.js'\n\nimport {\n  useComponentPresetProp,\n  useSelectableList, useSelectableListProps,\n  useValidation, useValidationProps, useValidationEmits, ValidationProps,\n  useFormFieldProps,\n  useLoadingProps,\n  useMaxSelections, useMaxSelectionsProps,\n  useClearableProps, useClearable, useClearableEmits,\n  useFocusDeep,\n  useTranslation,\n  useBem,\n  useThrottleProps,\n  useDropdownable, useDropdownableEmits, useDropdownableProps, useSyncProp,\n} from '../../composables'\n\nimport { VaInputWrapper } from '../va-input-wrapper'\nimport { VaDropdown, VaDropdownContent } from '../va-dropdown'\nimport { VaIcon } from '../va-icon'\nimport { VaSelectOptionList } from './components/VaSelectOptionList'\nimport { VaSelectContent } from './components/VaSelectContent'\n\nimport { useMaxVisibleOptions, useMaxVisibleOptionsProps } from './hooks/useMaxVisibleOptions'\nimport { useToggleIcon, useToggleIconProps } from './hooks/useToggleIcon'\nimport { useStringValue, useStringValueProps } from './hooks/useStringValue'\nimport { useAutocomplete, useAutocompleteProps } from './hooks/useAutocomplete'\nimport { useSelectAria } from './hooks/useSelectAria'\n\nimport { blurElement, focusElement } from '../../utils/focus'\nimport { unwrapEl } from '../../utils/unwrapEl'\nimport { isNilValue } from '../../utils/isNilValue'\nimport { warn } from '../../utils/console'\n\nimport type { SelectOption } from './types'\nimport type { DropdownOffsetProp } from '../va-dropdown/types'\nimport { extractComponentProps, filterComponentProps } from '../../utils/component-options'\n\nconst VaInputWrapperProps = extractComponentProps(VaInputWrapper)\n\nexport default defineComponent({\n  name: 'VaSelect',\n\n  components: {\n    VaSelectContent,\n    VaSelectOptionList,\n    VaIcon,\n    VaDropdown,\n    VaDropdownContent,\n    VaInputWrapper,\n  },\n\n  emits: [\n    'update:modelValue',\n    'update-search',\n    'create-new',\n    'scroll-bottom',\n    'update:search',\n    ...useDropdownableEmits,\n    ...useValidationEmits,\n    ...useClearableEmits,\n  ],\n\n  props: {\n    ...VaInputWrapperProps,\n    ...useComponentPresetProp,\n    ...useSelectableListProps,\n    ...useValidationProps as ValidationProps<SelectOption>,\n    ...useLoadingProps,\n    ...useMaxSelectionsProps,\n    ...useClearableProps,\n    ...useFormFieldProps,\n    ...useMaxVisibleOptionsProps,\n    ...useToggleIconProps,\n    ...useThrottleProps,\n    ...useStringValueProps,\n    ...useAutocompleteProps,\n    ...useDropdownableProps,\n\n    modelValue: {\n      type: [String, Number, Array, Object, Boolean] as PropType<SelectOption | SelectOption[]>,\n      default: '',\n    },\n\n    // Dropdown placement\n    placement: {\n      ...useDropdownableProps.placement,\n      default: 'bottom',\n    },\n\n    allowCreate: {\n      type: [Boolean, String] as PropType<boolean | 'unique'>,\n      default: false,\n      validator: (mode: string | boolean) => [true, false, 'unique'].includes(mode),\n    },\n\n    color: { type: String, default: 'primary' },\n    multiple: { type: Boolean, default: false },\n    searchable: { type: Boolean, default: false },\n    width: { type: String, default: '100%' },\n    maxHeight: { type: String, default: '256px' },\n    noOptionsText: { type: String, default: '$t:noOptions' },\n    hideSelected: { type: Boolean, default: false },\n    tabindex: { type: [String, Number], default: 0 },\n    virtualScroller: { type: Boolean, default: false },\n    selectedTopShown: { type: Boolean, default: false },\n    highlightMatchedText: { type: Boolean, default: true },\n    minSearchChars: { type: Number, default: 0 },\n    autoSelectFirstOption: { type: Boolean, default: false },\n\n    // Input style\n    placeholder: { type: String, default: '' },\n    searchPlaceholderText: { type: String, default: '$t:search' },\n\n    ariaLabel: { type: String, default: '$t:select' },\n    ariaSearchLabel: { type: String, default: '$t:optionsFilter' },\n    ariaClearLabel: { type: String, default: '$t:reset' },\n\n    search: { type: String, default: undefined },\n  },\n\n  setup (props, { emit, slots }) {\n    const { tp, t } = useTranslation()\n\n    const optionList = shallowRef<typeof VaSelectOptionList>()\n    const input = shallowRef<typeof VaInputWrapper>()\n    const searchBar = shallowRef<typeof VaInputWrapper>()\n\n    const isInputFocused = useFocusDeep(input as any)\n\n    const { getValue, getText, getTrackBy } = useSelectableList(props)\n\n    const onScrollBottom = () => emit('scroll-bottom')\n\n    const [searchVModel] = useSyncProp('search', props, emit, '')\n    const showSearchInput = computed(() => props.searchable || (props.allowCreate && !props.autocomplete))\n\n    watch(searchVModel, (value) => {\n      emit('update-search', value)\n      if (!props.autocomplete) {\n        hoveredOption.value = null\n      }\n    })\n\n    const getOptionByValue = (value: SelectOption): SelectOption => {\n      // if value is an object, it should be selectable option itself\n      if (isNilValue(value) || typeof value === 'object') { return value }\n\n      const optionByValue = props.options.find((option) => value === getValue(option))\n\n      if (optionByValue === undefined) {\n        warn(`[VaSelect]: can not find option in options list (${JSON.stringify(props.options)}) by provided value (${JSON.stringify(value)})!`)\n\n        return value\n      }\n\n      return optionByValue\n    }\n\n    const {\n      toggleHiddenOptionsState,\n      isAllOptionsShown,\n      visibleSelectedOptions,\n      hiddenSelectedOptionsAmount,\n      allSelectedOptions,\n    } = useMaxVisibleOptions(props, getOptionByValue)\n\n    // select value\n    const valueComputed = computed<SelectOption | SelectOption[]>({\n      get () {\n        if (props.multiple) { return allSelectedOptions.value }\n\n        const value = getOptionByValue(props.modelValue)\n\n        if (Array.isArray(value)) {\n          warn('Model value should be a string, number, boolean or an object for a single Select.')\n\n          if (value.length) {\n            return value.at(-1)\n          }\n        }\n\n        return value\n      },\n\n      set (option: SelectOption | SelectOption[]) {\n        if (Array.isArray(option)) {\n          emit('update:modelValue', option.map(getValue))\n        } else {\n          emit('update:modelValue', getValue(option))\n        }\n      },\n    })\n\n    const valueString = useStringValue(props, visibleSelectedOptions, getText)\n\n    // icons\n    const {\n      canBeCleared,\n      clearIconProps,\n      onFocus,\n      onBlur,\n    } = useClearable(props, valueComputed)\n\n    const showClearIcon = computed(() => {\n      if (!canBeCleared.value) { return false }\n      if (props.multiple && Array.isArray(valueComputed.value)) { return !!valueComputed.value.length }\n      return true\n    })\n\n    // options\n    const filteredOptions = computed(() => {\n      if (!props.options) { return [] }\n\n      if (props.selectedTopShown) {\n        return props.options.slice().sort((a, b) => {\n          const isASelected = checkIsOptionSelected(a)\n          const isBSelected = checkIsOptionSelected(b)\n\n          if (isASelected && isBSelected) { return 0 }\n          if (isASelected && !isBSelected) { return -1 }\n\n          return 1\n        })\n      }\n\n      if (props.hideSelected) {\n        return props.options.filter((option) => !checkIsOptionSelected(option))\n      }\n\n      return props.options\n    })\n\n    const checkIsOptionSelected = (option: SelectOption) => {\n      if (isNilValue(valueComputed.value)) { return false }\n\n      if (Array.isArray(valueComputed.value)) {\n        return !isNilValue(valueComputed.value.find((valueItem) => compareOptions(valueItem, option)))\n      }\n\n      return compareOptions(valueComputed.value, option)\n    }\n\n    const compareOptions = (option1: SelectOption, option2: SelectOption) => {\n      const one = getValue(option1)\n      const two = getValue(option2)\n\n      // identity check works nice for strings and exact matches.\n      if (one === two) {\n        return true\n      }\n      if (typeof one === 'string' && typeof two === 'string') {\n        return one === two\n      }\n      if (one === null || two === null) {\n        return false\n      }\n      if (typeof one === 'object' && typeof two === 'object') {\n        return getTrackBy(one) === getTrackBy(two)\n      }\n\n      return false\n    }\n\n    const isValueComputedArray = (v: Ref<SelectOption | SelectOption[]>): v is Ref<SelectOption[]> => Array.isArray(v.value)\n\n    const selectOption = (option: SelectOption) => {\n      if (hoveredOption.value === null) {\n        hideAndFocus()\n        return\n      }\n\n      if (showSearchInput.value) {\n        searchVModel.value = ''\n      }\n\n      if (props.multiple && isValueComputedArray(valueComputed)) {\n        const { exceedsMaxSelections, addOption } = useMaxSelections(valueComputed, ref(props.maxSelections))\n\n        const isSelected = checkIsOptionSelected(option)\n\n        if (isSelected) {\n          // Unselect\n          valueComputed.value = valueComputed.value.filter((optionSelected) => !compareOptions(option, optionSelected))\n        } else {\n          if (exceedsMaxSelections()) { return }\n          valueComputed.value = addOption(option)\n        }\n      } else {\n        valueComputed.value = typeof option !== 'object' ? option : { ...option }\n        hideAndFocus()\n      }\n\n      focusAutocompleteInput()\n    }\n\n    const addNewOption = () => {\n      // Do not emit if option already exist and allow create is `unique`\n      const hasAddedOption = props.options?.some((option: SelectOption) => [searchVModel.value, autocompleteValue.value].includes(getText(option)))\n\n      const allowedToCreateCheck = !((props.allowCreate === 'unique' || props.autocomplete) && hasAddedOption)\n      if (allowedToCreateCheck) {\n        emit('create-new', searchVModel.value || autocompleteValue.value)\n\n        searchVModel.value = ''\n        autocompleteValue.value = ''\n      }\n    }\n\n    // Hovered options\n\n    const hoveredOption = ref<SelectOption | null>(null)\n\n    const selectHoveredOption = () => {\n      if (isNilValue(hoveredOption.value)) { return }\n\n      if (!isOpenSync.value) {\n        // We can not select options if they are hidden\n        handleDropdownOpen()\n        return\n      }\n\n      selectOption(hoveredOption.value)\n    }\n\n    const selectOrAddOption = () => {\n      const allowedToCreate = !!props.allowCreate && (searchVModel.value || autocompleteValue.value)\n\n      if (hoveredOption.value !== null) {\n        selectHoveredOption()\n      } else if (allowedToCreate) {\n        addNewOption()\n      }\n    }\n\n    const focusPreviousOption = () => optionList.value?.focusPreviousOption()\n\n    const focusNextOption = () => optionList.value?.focusNextOption()\n\n    // Dropdown content\n\n    const { isOpenSync, dropdownProps } = useDropdownable(props, emit, {\n      defaultCloseOnValueUpdate: computed(() => !props.multiple),\n    })\n\n    const dropdownPropsComputed = computed(() => ({\n      ...dropdownProps.value,\n      closeOnContentClick: false,\n      stateful: false,\n      offset: [1, 0] as DropdownOffsetProp,\n      keepAnchorWidth: true,\n      keyboardNavigation: true,\n      innerAnchorSelector: '.va-input-wrapper__field',\n    }))\n\n    const showDropdownContentComputed = computed({\n      get: () => isOpenSync.value,\n      set: (show: boolean) => {\n        show ? handleDropdownOpen() : handleDropdownClose()\n      },\n    })\n\n    const handleDropdownOpen = () => {\n      if (props.disabled || props.readonly) { return }\n\n      isOpenSync.value = true\n      scrollToSelected()\n      focusSearchOrOptions()\n    }\n\n    const handleDropdownClose = () => {\n      isOpenSync.value = false\n      if (!props.autocomplete) {\n        searchVModel.value = ''\n      }\n      nextTick(() => {\n        validate()\n        isInputFocused.focusIfNothingIfFocused()\n      })\n    }\n\n    const hideAndFocus = () => {\n      handleDropdownClose()\n      isInputFocused.value = true\n    }\n\n    const focusSearchBar = () => {\n      searchBar.value?.focus()\n    }\n\n    const focusOptionList = () => {\n      optionList.value?.focus()\n      !props.modelValue && optionList.value?.focusFirstOption()\n    }\n\n    const focusSearchOrOptions = async () => {\n      await nextTick()\n\n      if (showSearchInput.value) {\n        focusSearchBar()\n      } else {\n        focusOptionList()\n      }\n    }\n\n    const onInputBlur = () => {\n      if (showDropdownContentComputed.value) { return }\n\n      onBlur()\n\n      isInputFocused.value\n        ? isInputFocused.value = false\n        : validate()\n    }\n\n    const tabIndexComputed = computed(() => props.disabled ? -1 : props.tabindex)\n    const openSelectButtonTabIndexComputed = computed(() => props.disabled || props.autocomplete ? -1 : 0)\n\n    const scrollToSelected = () => {\n      const selected = valueComputed.value\n      const nothingSelected = typeof selected !== 'object' && Array.isArray(selected) && !selected.length\n\n      if (nothingSelected) { return }\n\n      const scrollTo = Array.isArray(selected) ? selected[selected.length - 1] : selected\n      hoveredOption.value = scrollTo\n      nextTick(() => optionList.value?.scrollToOption(scrollTo))\n    }\n\n    // Hinted search\n\n    let hintedSearchQuery = ''\n    let hintedSearchQueryTimeoutIndex!: ReturnType<typeof setTimeout>\n    const navigationKeys = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Enter', ' ']\n\n    // Hinted search - hover option if you typing it's value on select without search-bar\n    const onHintedSearch = (event: KeyboardEvent) => {\n      if (navigationKeys.some(key => key === event.key)) {\n        return\n      }\n\n      const isLetter: boolean = event.key.length === 1\n      const isDeleteKey: boolean = event.key === 'Backspace' || event.key === 'Delete'\n\n      clearTimeout(hintedSearchQueryTimeoutIndex)\n\n      if (isDeleteKey) {\n        // Remove last letter from query\n        hintedSearchQuery = hintedSearchQuery ? hintedSearchQuery.slice(0, -1) : ''\n      } else if (isLetter) {\n        // Add every new letter to the query\n        hintedSearchQuery += event.key\n      }\n\n      if (showSearchInput.value) {\n        searchVModel.value = hintedSearchQuery\n        return\n      }\n\n      // Search for an option that matches the query\n      if (hintedSearchQuery) {\n        const appropriateOption = props.options.find(option => getText(option).toLowerCase().startsWith(hintedSearchQuery.toLowerCase()))\n        if (appropriateOption) {\n          hoveredOption.value = appropriateOption\n        }\n      }\n\n      hintedSearchQueryTimeoutIndex = setTimeout(() => { hintedSearchQuery = '' }, 1000)\n    }\n\n    const optionsListPropsComputed = computed(() => ({\n      ...pick(props, ['textBy', 'trackBy', 'groupBy', 'valueBy', 'disabledBy', 'color', 'virtualScroller', 'highlightMatchedText', 'minSearchChars', 'delay', 'selectedTopShown']),\n      autoSelectFirstOption: props.autoSelectFirstOption || props.autocomplete,\n      search: searchVModel.value || autocompleteValue.value,\n      tabindex: tabIndexComputed.value,\n      selectedValue: valueComputed.value,\n      options: filteredOptions.value,\n      getSelectedState: checkIsOptionSelected,\n      noOptionsText: tp(props.noOptionsText),\n    }))\n\n    const { toggleIcon, toggleIconColor } = useToggleIcon(props, isOpenSync)\n\n    // input wrapper\n    const isFocused = computed(() => isInputFocused.value || isOpenSync.value)\n    const inputWrapperClassComputed = useBem('va-select-anchor', () => ({\n      nowrap: !!(props.maxVisibleOptions && !slots.content),\n    }))\n    const vaInputWrapperProps = filterComponentProps(VaInputWrapperProps)\n    const inputWrapperPropsComputed = computed(() => ({\n      ...vaInputWrapperProps.value,\n      error: computedError.value,\n      errorMessages: computedErrorMessages.value,\n      focused: isFocused.value,\n      'aria-label': props.ariaLabel || (props.modelValue ? `${t('selectedOption')}: ${props.modelValue}` : t('noSelectedOption')),\n    }))\n\n    // select content\n    const selectContentPropsComputed = computed(() => ({\n      ...pick(props, ['placeholder', 'autocomplete', 'multiple', 'disabled', 'readonly']),\n      tabindex: tabIndexComputed.value,\n      value: visibleSelectedOptions.value,\n      valueString: valueString.value,\n      hiddenSelectedOptionsAmount: hiddenSelectedOptionsAmount.value,\n      isAllOptionsShown: isAllOptionsShown.value,\n      focused: isInputFocused.value,\n      autocompleteInputValue: autocompleteValue.value,\n      getText,\n    }))\n\n    // autocomplete\n    const autocompleteValue = useAutocomplete(searchVModel, props, visibleSelectedOptions, isOpenSync, getText)\n    const setAutocompleteValue = (v: string) => (autocompleteValue.value = v)\n\n    // public methods\n    const focus = () => {\n      if (props.disabled) { return }\n      focusElement(unwrapEl(input.value))\n    }\n\n    const blur = () => {\n      if (showDropdownContentComputed.value) {\n        showDropdownContentComputed.value = false\n      }\n\n      nextTick(() => {\n        if (props.disabled) { return }\n        blurElement(unwrapEl(input.value))\n      })\n    }\n\n    const reset = () => withoutValidation(() => {\n      if (props.multiple) {\n        valueComputed.value = Array.isArray(props.clearValue) ? props.clearValue : []\n      } else {\n        valueComputed.value = props.clearValue\n      }\n\n      searchVModel.value = ''\n      emit('clear')\n      resetValidation()\n      nextTick(() => {\n        isInputFocused.value = true\n      })\n    })\n\n    const focusAutocompleteInput = (e?: Event) => {\n      if (props.autocomplete && !props.disabled && !props.readonly) {\n        e?.stopImmediatePropagation()\n\n        isInputFocused.value = true\n        isOpenSync.value = true\n      }\n    }\n\n    const toggleDropdown = (e: KeyboardEvent) => {\n      if (props.disabled || props.readonly) { return }\n\n      if (e.code === 'Space' && props.autocomplete) { return }\n\n      showDropdownContentComputed.value = !showDropdownContentComputed.value\n    }\n\n    const deleteLastSelected = () => {\n      if (!Array.isArray(valueComputed.value)) { return }\n\n      valueComputed.value = valueComputed.value.slice(0, -1)\n    }\n\n    const {\n      validate,\n      computedError,\n      computedErrorMessages,\n      withoutValidation,\n      resetValidation,\n    } = useValidation(props, emit, { reset, focus, value: valueComputed })\n\n    return {\n      ...useSelectAria(),\n      input,\n      optionList,\n      searchBar,\n\n      reset,\n      focus,\n      blur,\n      toggleDropdown,\n      deleteLastSelected,\n\n      focusAutocompleteInput,\n\n      tp,\n      t,\n\n      onInputFocus: onFocus,\n      onInputBlur,\n      focusOptionList,\n      focusSearchBar,\n      searchInput: searchVModel,\n      showSearchInput,\n      hoveredOption,\n      tabIndexComputed,\n      valueString,\n      showClearIcon,\n      toggleIcon,\n      selectOption,\n      selectOrAddOption,\n      selectHoveredOption,\n      focusPreviousOption,\n      focusNextOption,\n      showDropdownContentComputed,\n      handleDropdownOpen,\n      handleDropdownClose,\n      hideAndFocus,\n      toggleIconColor,\n      onHintedSearch,\n      onScrollBottom,\n      clearIconProps,\n      dropdownPropsComputed,\n      visibleSelectedOptions,\n      optionsListPropsComputed,\n      toggleHiddenOptionsState,\n      setAutocompleteValue,\n\n      inputWrapperPropsComputed,\n      inputWrapperClassComputed,\n      selectContentPropsComputed,\n      openSelectButtonTabIndexComputed,\n\n      // for e2e tests\n      getOptionByValue,\n      compareOptions,\n      getText,\n    }\n  },\n})\n</script>\n\n<style lang=\"scss\">\n@import \"../../styles/resources\";\n@import \"variables\";\n\n.va-select {\n  & .va-input-wrapper__text {\n    line-height: normal;\n    flex-wrap: wrap;\n  }\n}\n\n.va-select-anchor {\n  &__input {\n    cursor: var(--va-select-cursor);\n    flex: 1;\n  }\n\n  &--nowrap {\n    .va-input-wrapper__text {\n      flex-wrap: nowrap;\n    }\n  }\n}\n\n.va-select-dropdown {\n  &__content {\n    overflow: hidden;\n    border-top-right-radius: 0;\n    border-top-left-radius: 0;\n    padding: 0;\n  }\n\n  &__content-search-input {\n    min-width: auto;\n    width: 100%;\n  }\n\n  &__options-wrapper {\n    background: var(--va-select-dropdown-background);\n    overflow-y: auto;\n\n    @include va-scroll(var(--va-background-element));\n  }\n}\n</style>\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}