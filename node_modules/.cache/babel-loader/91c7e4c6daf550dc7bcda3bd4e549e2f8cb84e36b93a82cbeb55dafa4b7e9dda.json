{"ast":null,"code":"import { ref, watch, computed } from \"vue\";\nconst useStatefulProps = {\n  stateful: {\n    type: Boolean,\n    default: false\n  },\n  modelValue: {\n    type: void 0\n  }\n};\nconst createStatefulProps = (statefulDefault = false) => {\n  return {\n    stateful: {\n      type: Boolean,\n      default: statefulDefault\n    }\n  };\n};\nconst useStatefulEmits = [\"update:modelValue\"];\nconst useStateful = (props, emit, key = \"modelValue\", options = {}) => {\n  const {\n    defaultValue,\n    eventName\n  } = options;\n  const event = eventName || `update:${key.toString()}`;\n  const valueState = ref(defaultValue === void 0 ? props[key] : defaultValue);\n  let unwatchModelValue;\n  const watchModelValue = () => {\n    unwatchModelValue = watch(() => props[key], modelValue => {\n      valueState.value = modelValue;\n    });\n  };\n  watch(() => props.stateful, stateful => {\n    stateful ? watchModelValue() : unwatchModelValue == null ? void 0 : unwatchModelValue();\n  }, {\n    immediate: true\n  });\n  const valueComputed = computed({\n    get: () => {\n      if (props.stateful) {\n        return valueState.value;\n      }\n      return props[key];\n    },\n    set: value => {\n      if (props.stateful) {\n        valueState.value = value;\n      }\n      emit(event, value);\n    }\n  });\n  return {\n    valueComputed\n  };\n};\nexport { useStatefulProps as a, useStateful as b, createStatefulProps as c, useStatefulEmits as u };","map":{"version":3,"names":["useStatefulProps","stateful","type","Boolean","default","modelValue","createStatefulProps","statefulDefault","useStatefulEmits","useStateful","props","emit","key","options","defaultValue","eventName","event","toString","valueState","ref","unwatchModelValue","watchModelValue","watch","value","immediate","valueComputed","computed","get","set"],"sources":["../../../../src/composables/useStateful.ts"],"sourcesContent":["import { ref, computed, watch, PropType, Ref } from 'vue'\n\nexport type StatefulProps = {\n  stateful: boolean\n}\n\nexport type StatefulOptions<T> = {\n  eventName?: string\n  /** @deprecated set default value for prop, not here */\n  defaultValue?: T\n}\n\ntype NonUndefined<T extends any> = T extends undefined ? never : T\n\n/**\n * You could add these props to any component by destructuring them inside props option.\n * @example\n * props: { ...useStatefulProps, componentsOwnProp, etc. }\n * It's better to add props at the beginning, to make sure that Component own props will be used instead in case of collision\n */\nexport const useStatefulProps = {\n  stateful: { type: Boolean as PropType<boolean>, default: false },\n  modelValue: { type: undefined as any },\n}\n\nexport const createStatefulProps = (statefulDefault = false) => {\n  return {\n    stateful: { type: Boolean as PropType<boolean>, default: statefulDefault },\n  }\n}\n\nexport const useStatefulEmits = ['update:modelValue'] as const\n\n/**\n * Returns `valueComputed` that is proxy for `modelValue` or given key of the props\n * if `stateful` prop is `false`\n * Record<any, any> & Record<'modelValue', T>\n */\nexport const useStateful = <\n  T,\n  D extends any,\n  O extends StatefulOptions<D>,\n  Key extends string = 'modelValue',\n  P extends StatefulProps & { [key in Key]?: T } = StatefulProps & { [key in Key]?: T },\n>(\n    props: P,\n    emit: (name: `update:${Key}`, ...args: any[]) => void,\n    key: Key = 'modelValue' as Key,\n    options: O = {} as O,\n  ) => {\n  const { defaultValue, eventName } = options\n  const event = (eventName || `update:${key.toString()}`) as `update:${Key}`\n  const valueState = ref(defaultValue === undefined ? props[key] : defaultValue) as Ref\n  let unwatchModelValue: Function\n\n  const watchModelValue = () => {\n    unwatchModelValue = watch(() => props[key], (modelValue) => {\n      valueState.value = modelValue\n    })\n  }\n\n  watch(() => props.stateful, (stateful: boolean) => {\n    stateful ? watchModelValue() : unwatchModelValue?.()\n  }, { immediate: true })\n\n  const valueComputed = computed<unknown extends O['defaultValue'] ? P[Key] : NonUndefined<P[Key]>>({\n    get: () => {\n      if (props.stateful) { return valueState.value }\n\n      return props[key]\n    },\n    set: (value) => {\n      if (props.stateful) { valueState.value = value }\n\n      emit(event, value)\n    },\n  })\n\n  return { valueComputed }\n}\n"],"mappings":";AAoBO,MAAMA,gBAAA,GAAmB;EAC9BC,QAAA,EAAU;IAAEC,IAAA,EAAMC,OAAA;IAA8BC,OAAA,EAAS;EAAM;EAC/DC,UAAA,EAAY;IAAEH,IAAA,EAAM;EAAiB;AACvC;AAEa,MAAAI,mBAAA,GAAsBA,CAACC,eAAA,GAAkB,UAAU;EACvD;IACLN,QAAA,EAAU;MAAEC,IAAA,EAAMC,OAAA;MAA8BC,OAAA,EAASG;IAAgB;EAAA;AAE7E;AAEa,MAAAC,gBAAA,GAAmB,CAAC,mBAAmB;AAOvC,MAAAC,WAAA,GAAcA,CAOvBC,KAAA,EACAC,IAAA,EACAC,GAAA,GAAW,cACXC,OAAA,GAAa,OACV;EACC;IAAEC,YAAA;IAAcC;EAAc,IAAAF,OAAA;EACpC,MAAMG,KAAA,GAASD,SAAA,IAAa,UAAUH,GAAA,CAAIK,QAAA,CAAS;EACnD,MAAMC,UAAA,GAAaC,GAAA,CAAIL,YAAA,KAAiB,SAAYJ,KAAA,CAAME,GAAG,IAAIE,YAAY;EACzE,IAAAM,iBAAA;EAEJ,MAAMC,eAAA,GAAkBA,CAAA,KAAM;IAC5BD,iBAAA,GAAoBE,KAAA,CAAM,MAAMZ,KAAA,CAAME,GAAG,GAAIP,UAAA,IAAe;MAC1Da,UAAA,CAAWK,KAAA,GAAQlB,UAAA;IAAA,CACpB;EAAA;EAGHiB,KAAA,CAAM,MAAMZ,KAAA,CAAMT,QAAA,EAAWA,QAAA,IAAsB;IACtCA,QAAA,GAAAoB,eAAA,KAAoBD,iBAAA,oBAAAA,iBAAA;EAAoB,GAClD;IAAEI,SAAA,EAAW;EAAA,CAAM;EAEtB,MAAMC,aAAA,GAAgBC,QAAA,CAA4E;IAChGC,GAAA,EAAKA,CAAA,KAAM;MACT,IAAIjB,KAAA,CAAMT,QAAA,EAAU;QAAE,OAAOiB,UAAA,CAAWK,KAAA;MAAM;MAE9C,OAAOb,KAAA,CAAME,GAAG;IAClB;IACAgB,GAAA,EAAML,KAAA,IAAU;MACd,IAAIb,KAAA,CAAMT,QAAA,EAAU;QAAEiB,UAAA,CAAWK,KAAA,GAAQA,KAAA;MAAM;MAE/CZ,IAAA,CAAKK,KAAA,EAAOO,KAAK;IACnB;EAAA,CACD;EAED,OAAO;IAAEE;EAAc;AACzB"},"metadata":{},"sourceType":"module","externalDependencies":[]}