{"ast":null,"code":"import { Comment, h, Text, Suspense, Teleport, Fragment } from \"vue\";\nconst toNode = (v, attrs) => {\n  if (!v) {\n    return null;\n  }\n  if (!(\"type\" in v) || v.type === Text || typeof v === \"string\") {\n    return h(\"div\", attrs, v);\n  }\n  if (v.type === Comment) {\n    return v;\n  }\n  if (\"$el\" in v) {\n    return toNode(v.$el, attrs);\n  }\n  if (v.type === Suspense) {\n    return h(v.ssContent, attrs);\n  }\n  if (v.type === Teleport) {\n    if (v.children === null) {\n      return v;\n    }\n    const anchor = toNode(v.children[0], attrs);\n    if (anchor) {\n      v.children[0] = h(anchor, attrs);\n    }\n    return v;\n  }\n  if (v.type === Fragment) {\n    if (v.children === null) {\n      return v;\n    }\n    if (v.children.length === 1) {\n      return h(Fragment, v.props, [toNode(v.children[0], attrs)]);\n    }\n    return h(\"div\", attrs, v);\n  }\n  if (typeof v.type.render === \"function\") {\n    const component = h(v);\n    if (Array.isArray(component.children) && component.children.length > 1) {\n      return h(\"div\", attrs, component.children);\n    }\n  }\n  return h(v, attrs);\n};\nconst renderSlotNode = (slot, slotBind = {}, nodeAttributes = {}) => {\n  const children = slot == null ? void 0 : slot(slotBind);\n  if (!children) {\n    return null;\n  }\n  const nonCommentChildren = children.filter(v => v.type !== Comment);\n  if (nonCommentChildren.length === 0) {\n    return null;\n  }\n  if (nonCommentChildren.length === 1) {\n    return toNode(nonCommentChildren[0], nodeAttributes);\n  }\n  return h(\"div\", nodeAttributes, children);\n};\nconst renderSlotNodes = (slot, slotBind = {}, nodeAttributes = {}) => {\n  const children = slot == null ? void 0 : slot(slotBind);\n  if (!children) {\n    return null;\n  }\n  return children.map(v => toNode(v, nodeAttributes));\n};\nexport { renderSlotNode as a, renderSlotNodes as r };","map":{"version":3,"names":["toNode","v","attrs","type","Text","h","Comment","$el","Suspense","ssContent","Teleport","children","anchor","Fragment","length","props","render","component","Array","isArray","renderSlotNode","slot","slotBind","nodeAttributes","nonCommentChildren","filter","renderSlotNodes","map"],"sources":["../../../../src/utils/headless.ts"],"sourcesContent":["import { VNode, h, Teleport, Suspense, Comment, Fragment, Text, Slot } from 'vue'\n\ntype NodeAttributes = Record<string, any>\n\nconst toNode = (v: any, attrs: NodeAttributes): VNode | null => {\n  if (!v) { return null }\n\n  if (!('type' in v) || v.type === Text || typeof v === 'string') {\n    return h('div', attrs, v)\n  }\n\n  if (v.type === Comment) {\n    return v\n  }\n\n  if ('$el' in v) {\n    return toNode(v.$el, attrs)\n  }\n\n  if ((v.type as any) === Suspense) {\n    // Suspense is not supported, we just return default content. I'm not sure\n    // how to check if Suspense is ready to show default content instead of fallback.\n    // Since Suspense is still experimental let's just ignore it for now.\n    return h(v.ssContent, attrs) // TODO: Render decide when render fallback\n  }\n\n  if ((v.type as any) === Teleport) {\n    if (v.children === null) { return v }\n\n    const anchor = toNode(v.children[0], attrs)\n\n    if (anchor) {\n      v.children[0] = h(anchor, attrs)\n    }\n    return v\n  }\n\n  if (v.type === Fragment) {\n    if (v.children === null) { return v }\n    if (v.children.length === 1) { return h(Fragment, v.props, [toNode(v.children[0], attrs)]) }\n    return h('div', attrs, v)\n  }\n\n  if (typeof v.type.render === 'function') {\n    const component = h(v)\n\n    if (Array.isArray(component.children) && component.children.length > 1) {\n      return h('div', attrs, component.children)\n    }\n  }\n\n  return h(v, attrs)\n}\n\n/** Renders node, apply slot bind and attributes to actual HTML Node, not vue pseudo elements */\nexport const renderSlotNode = (slot: Slot | undefined, slotBind: any = {}, nodeAttributes: NodeAttributes = {}) => {\n  const children = slot?.(slotBind)\n\n  if (!children) { return null }\n\n  const nonCommentChildren = children.filter((v) => v.type !== Comment)\n\n  if (nonCommentChildren.length === 0) { return null }\n  if (nonCommentChildren.length === 1) { return toNode(nonCommentChildren[0], nodeAttributes) }\n\n  return h('div', nodeAttributes, children)\n}\n\nexport const renderSlotNodes = (slot: Slot | undefined, slotBind: any = {}, nodeAttributes: NodeAttributes = {}) => {\n  const children = slot?.(slotBind)\n\n  if (!children) { return null }\n\n  // Convert to Node first non-comment child or first child\n  return children.map((v) => toNode(v, nodeAttributes))\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}