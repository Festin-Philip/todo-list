{"ast":null,"code":"import { computed } from \"vue\";\nimport { p as placementsPositionsWithAliases, u as usePlacementAliases } from \"../../../composables/usePlacementAliases-c092b4d3.mjs\";\nimport { u as useParsableMeasure } from \"../../../composables/useParsableMeasure-df21fd20.mjs\";\nconst {\n  isParsableMeasure,\n  parseSizeValue\n} = useParsableMeasure();\nconst useFloatingPositionProps = {\n  overlap: {\n    type: Boolean,\n    default: false\n  },\n  placement: {\n    type: String,\n    default: \"top-end\",\n    validator: position => placementsPositionsWithAliases.includes(position)\n  },\n  offset: {\n    type: [Number, String, Array],\n    default: 0,\n    validator: value => {\n      if (Array.isArray(value)) {\n        return value.every(isParsableMeasure);\n      }\n      if (typeof value === \"string\") {\n        return isParsableMeasure(value);\n      }\n      return !isNaN(value);\n    }\n  }\n};\nconst useFloatingPosition = (props, floating) => {\n  if (!floating.value) {\n    return {};\n  }\n  const {\n    position,\n    align\n  } = usePlacementAliases(props);\n  const alignmentShiftComputed = computed(() => {\n    const alignOptions = {\n      start: props.overlap ? \"-50%\" : \"-100%\",\n      center: \"-50%\",\n      end: props.overlap ? \"-50%\" : \"0%\"\n    };\n    return alignOptions[align.value];\n  });\n  const offsetMarginComputed = computed(() => {\n    if (!props.offset) {\n      return {};\n    }\n    const mainAxis = [\"left\", \"right\"].includes(position.value) ? \"top\" : \"left\";\n    const crossAxis = mainAxis === \"top\" ? \"left\" : \"top\";\n    if (Array.isArray(props.offset)) {\n      const [x, y] = props.offset.map(parseSizeValue);\n      return {\n        [`margin-${mainAxis}`]: `${x}px`,\n        [`margin-${crossAxis}`]: `${y}px`\n      };\n    }\n    const offset = parseSizeValue(props.offset);\n    return {\n      [`margin-${crossAxis}`]: `${offset}px`\n    };\n  });\n  const alignmentComputed = computed(() => {\n    const mainAxis = [\"left\", \"right\"].includes(position.value) ? \"top\" : \"left\";\n    const crossAxis = mainAxis === \"top\" ? \"left\" : \"top\";\n    let shiftValue = \"0%\";\n    if (crossAxis === \"top\" && position.value === \"bottom\") {\n      shiftValue = \"100%\";\n    }\n    if (crossAxis === \"left\" && position.value === \"right\") {\n      shiftValue = \"100%\";\n    }\n    const alignmentOptions = {\n      start: {\n        [mainAxis]: \"0%\",\n        [crossAxis]: shiftValue\n      },\n      center: {\n        [mainAxis]: \"50%\",\n        [crossAxis]: shiftValue\n      },\n      end: {\n        [mainAxis]: \"100%\",\n        [crossAxis]: shiftValue\n      }\n    };\n    return alignmentOptions[align.value];\n  });\n  const transformComputed = computed(() => {\n    const coords = {\n      top: {\n        x: alignmentShiftComputed.value,\n        y: props.overlap ? \"-50%\" : \"-100%\"\n      },\n      bottom: {\n        x: alignmentShiftComputed.value,\n        y: props.overlap ? \"-50%\" : \"0%\"\n      },\n      left: {\n        x: props.overlap ? \"-50%\" : \"-100%\",\n        y: alignmentShiftComputed.value\n      },\n      right: {\n        x: props.overlap ? \"-50%\" : \"0%\",\n        y: alignmentShiftComputed.value\n      }\n    };\n    const {\n      x,\n      y\n    } = coords[position.value];\n    return {\n      transform: `translate(${x}, ${y})`\n    };\n  });\n  return computed(() => ({\n    ...alignmentComputed.value,\n    ...transformComputed.value,\n    ...offsetMarginComputed.value\n  }));\n};\nexport { useFloatingPosition as a, useFloatingPositionProps as u };","map":{"version":3,"names":["isParsableMeasure","parseSizeValue","useParsableMeasure","useFloatingPositionProps","overlap","type","Boolean","default","placement","String","validator","position","placementsPositionsWithAliases","includes","offset","Number","Array","value","isArray","every","isNaN","useFloatingPosition","props","floating","align","usePlacementAliases","alignmentShiftComputed","computed","alignOptions","start","center","end","offsetMarginComputed","mainAxis","crossAxis","x","y","map","alignmentComputed","shiftValue","alignmentOptions","transformComputed","coords","top","bottom","left","right","transform"],"sources":["../../../../../../src/components/va-badge/hooks/useFloatingPositionStyles.ts"],"sourcesContent":["import type { ExtractPropTypes, PropType, Ref } from 'vue'\n\nimport type { PlacementWithAlias } from '../../../composables'\nimport type { BadgeOffsetProp } from '../types'\n\nimport { computed } from 'vue'\n\nimport { usePlacementAliases, placementsPositionsWithAliases, useParsableMeasure } from '../../../composables'\n\nconst { isParsableMeasure, parseSizeValue } = useParsableMeasure()\n\nexport const useFloatingPositionProps = {\n  overlap: { type: Boolean, default: false },\n  placement: {\n    type: String as PropType<PlacementWithAlias>,\n    default: 'top-end',\n    validator: (position: PlacementWithAlias) => placementsPositionsWithAliases.includes(position),\n  },\n  offset: {\n    type: [Number, String, Array] as PropType<BadgeOffsetProp>,\n    default: 0,\n    validator: (value: keyof BadgeOffsetProp) => {\n      if (Array.isArray(value)) {\n        return value.every(isParsableMeasure)\n      }\n\n      if (typeof value === 'string') {\n        return isParsableMeasure(value)\n      }\n\n      return !isNaN(value)\n    },\n  },\n}\n\nexport const useFloatingPosition = (\n  props: ExtractPropTypes<typeof useFloatingPositionProps>,\n  floating: Ref<boolean>,\n) => {\n  if (!floating.value) { return {} }\n\n  const { position, align } = usePlacementAliases(props)\n\n  const alignmentShiftComputed = computed(() => {\n    const alignOptions = {\n      start: props.overlap ? '-50%' : '-100%',\n      center: '-50%',\n      end: props.overlap ? '-50%' : '0%',\n    }\n\n    return alignOptions[align.value]\n  })\n\n  const offsetMarginComputed = computed(() => {\n    if (!props.offset) { return {} }\n\n    const mainAxis = ['left', 'right'].includes(position.value) ? 'top' : 'left'\n    const crossAxis = mainAxis === 'top' ? 'left' : 'top'\n\n    if (Array.isArray(props.offset)) {\n      const [x, y] = props.offset.map(parseSizeValue)\n\n      return {\n        [`margin-${mainAxis}`]: `${x}px`,\n        [`margin-${crossAxis}`]: `${y}px`,\n      }\n    }\n\n    const offset = parseSizeValue(props.offset)\n\n    return {\n      [`margin-${crossAxis}`]: `${offset}px`,\n    }\n  })\n\n  const alignmentComputed = computed(() => {\n    const mainAxis = ['left', 'right'].includes(position.value) ? 'top' : 'left'\n    const crossAxis = mainAxis === 'top' ? 'left' : 'top'\n    let shiftValue = '0%'\n\n    if (crossAxis === 'top' && position.value === 'bottom') {\n      shiftValue = '100%'\n    }\n\n    if (crossAxis === 'left' && position.value === 'right') {\n      shiftValue = '100%'\n    }\n\n    const alignmentOptions = {\n      start: { [mainAxis]: '0%', [crossAxis]: shiftValue },\n      center: { [mainAxis]: '50%', [crossAxis]: shiftValue },\n      end: { [mainAxis]: '100%', [crossAxis]: shiftValue },\n    }\n\n    return alignmentOptions[align.value]\n  })\n\n  const transformComputed = computed(() => {\n    const coords = {\n      top: {\n        x: alignmentShiftComputed.value,\n        y: props.overlap ? '-50%' : '-100%',\n      },\n      bottom: {\n        x: alignmentShiftComputed.value,\n        y: props.overlap ? '-50%' : '0%',\n      },\n      left: {\n        x: props.overlap ? '-50%' : '-100%',\n        y: alignmentShiftComputed.value,\n      },\n      right: {\n        x: props.overlap ? '-50%' : '0%',\n        y: alignmentShiftComputed.value,\n      },\n    }\n\n    const { x, y } = coords[position.value]\n\n    return { transform: `translate(${x}, ${y})` }\n  })\n\n  return computed(() => ({\n    ...alignmentComputed.value,\n    ...transformComputed.value,\n    ...offsetMarginComputed.value,\n  }))\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}