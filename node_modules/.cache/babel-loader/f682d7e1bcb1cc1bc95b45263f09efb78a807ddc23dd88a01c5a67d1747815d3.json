{"ast":null,"code":"import { k as kebabCase, j as camelCase } from \"../../../vendor-2b2dbafd.mjs\";\nimport { ColorTranslator } from \"colortranslator\";\nconst makeColor = color => {\n  try {\n    return new ColorTranslator(color);\n  } catch (e) {\n    throw new Error(`Color ${color} is not valid. Please, provide valid color.`, {\n      cause: e\n    });\n  }\n};\nconst isCSSVariable = strColor => /var\\(--.+\\)/.test(strColor);\nconst cssVariableName = colorName => `--va-${kebabCase(colorName)}`;\nconst normalizeColorName = colorName => camelCase(colorName);\nconst colorToRgba = (color, opacity) => {\n  return makeColor(color).setA(opacity).RGBA;\n};\nconst getColorLightness = color => {\n  const {\n    R,\n    G,\n    B\n  } = makeColor(color);\n  return Math.sqrt(R * R * 0.241 + G * G * 0.691 + B * B * 0.068);\n};\nconst getBoxShadowColor = (color, opacity = 0.4) => {\n  return makeColor(color).setA(opacity).RGBA;\n};\nconst getBoxShadowColorFromBg = (background, opacity = 0.4) => {\n  return makeColor(background).setA(opacity).RGBA;\n};\nconst getHoverColor = (color, opacity = 0.2) => {\n  return makeColor(color).setA(opacity).RGBA;\n};\nconst getFocusColor = (color, opacity = 0.3) => {\n  return makeColor(color).setA(opacity).RGBA;\n};\nconst shiftHSLAColor = (color, offset) => {\n  const result = makeColor(color);\n  if (offset.h) {\n    result.setH(result.H + offset.h);\n  }\n  if (offset.s) {\n    result.setS(result.S + offset.s);\n  }\n  if (offset.l) {\n    result.setL(result.L + offset.l);\n  }\n  if (offset.a) {\n    result.setA(result.A + offset.a);\n  }\n  return result.HSLA;\n};\nconst setHSLAColor = (color, newColor) => {\n  const result = makeColor(color);\n  if (newColor.h !== void 0) {\n    result.setH(newColor.h);\n  }\n  if (newColor.s !== void 0) {\n    result.setS(newColor.s);\n  }\n  if (newColor.l !== void 0) {\n    result.setL(newColor.l);\n  }\n  if (newColor.a !== void 0) {\n    result.setA(newColor.a);\n  }\n  return result.HSLA;\n};\nconst shiftGradientColor = color => {\n  const newColor = ColorTranslator.toHSLA(color, false);\n  if (newColor.s < 10) {\n    return shiftHSLAColor(newColor, {\n      h: 2,\n      s: 5,\n      l: 10\n    });\n  }\n  if (newColor.s < 30) {\n    return shiftHSLAColor(newColor, {\n      s: -14,\n      l: 11\n    });\n  }\n  if (newColor.h >= 0 && newColor.h < 44 || newColor.h >= 285) {\n    return shiftHSLAColor(newColor, {\n      h: 11,\n      s: 27,\n      l: 8\n    });\n  }\n  if (newColor.h >= 44 && newColor.h < 85) {\n    return shiftHSLAColor(newColor, {\n      h: 3,\n      l: 9\n    });\n  }\n  if (newColor.h >= 85 && newColor.h < 165) {\n    return shiftHSLAColor(newColor, {\n      h: 16,\n      l: 14\n    });\n  }\n  if (newColor.h >= 165 && newColor.h < 285) {\n    return shiftHSLAColor(newColor, {\n      h: -15,\n      s: 3,\n      l: 2\n    });\n  }\n  throw new Error(\"This method should handle all colors. But it didn't for some reason.\");\n};\nconst getGradientBackground = color => {\n  const colorLeft = shiftGradientColor(color);\n  const colorRight = ColorTranslator.toHSLA(color);\n  return `linear-gradient(to right, ${colorLeft}, ${colorRight})`;\n};\nconst getStateMaskGradientBackground = (color, maskColor, maskOpacity) => {\n  const mask = colorToRgba(maskColor, maskOpacity);\n  return `linear-gradient(0deg, ${mask}, ${mask}), ${color}`;\n};\nconst isColor = strColor => {\n  const cssColorRegex = /^#([\\da-f]{3}){1,2}$|^#([\\da-f]{4}){1,2}$|(rgb|hsl)a?\\((\\s*-?\\d+%?\\s*,){2}(\\s*-?\\d+%?\\s*,?\\s*\\)?)(,\\s*(0?\\.\\d+)?|1)?\\)/;\n  return cssColorRegex.test(strColor.toLocaleLowerCase());\n};\nconst applyColors = (color1, color2) => {\n  const c1 = makeColor(color1);\n  const c2 = makeColor(color2);\n  const weight = c2.A;\n  if (weight === 1) {\n    return c2.RGBA;\n  }\n  if (weight === 0) {\n    return c1.RGBA;\n  }\n  c1.setR(Math.round(c1.R * (1 - weight) + c2.R * weight));\n  c1.setG(Math.round(c1.G * (1 - weight) + c2.G * weight));\n  c1.setB(Math.round(c1.B * (1 - weight) + c2.B * weight));\n  return c1.RGBA;\n};\nconst isColorTransparent = color => {\n  if (!color) {\n    return false;\n  }\n  if (color === \"transparent\") {\n    return true;\n  }\n  return makeColor(color).A <= 0.1;\n};\nexport { getBoxShadowColor as a, getFocusColor as b, getHoverColor as c, colorToRgba as d, applyColors as e, getBoxShadowColorFromBg as f, getGradientBackground as g, setHSLAColor as h, isColorTransparent as i, getStateMaskGradientBackground as j, cssVariableName as k, isColor as l, isCSSVariable as m, normalizeColorName as n, getColorLightness as o, shiftHSLAColor as s };","map":{"version":3,"names":["makeColor","color","ColorTranslator","e","Error","cause","isCSSVariable","strColor","test","cssVariableName","colorName","kebabCase","normalizeColorName","camelCase","colorToRgba","opacity","setA","RGBA","getColorLightness","R","G","B","Math","sqrt","getBoxShadowColor","getBoxShadowColorFromBg","background","getHoverColor","getFocusColor","shiftHSLAColor","offset","result","h","setH","H","s","setS","S","l","setL","L","a","A","HSLA","setHSLAColor","newColor","shiftGradientColor","toHSLA","getGradientBackground","colorLeft","colorRight","getStateMaskGradientBackground","maskColor","maskOpacity","mask","isColor","cssColorRegex","toLocaleLowerCase","applyColors","color1","color2","c1","c2","weight","setR","round","setG","setB","isColorTransparent"],"sources":["../../../../../src/services/color/utils.ts"],"sourcesContent":["import kebabCase from 'lodash/kebabCase.js'\nimport camelCase from 'lodash/camelCase.js'\nimport { ColorTranslator } from 'colortranslator'\nimport type { HSLObject, HEXObject, RGBObject } from 'colortranslator'\nimport { warn } from 'vue'\n\nexport type ColorInput = string | HEXObject | HSLObject | RGBObject\n\nconst makeColor = (color: ColorInput) => {\n  try {\n    return new ColorTranslator(color)\n  } catch (e) {\n    throw new Error(`Color ${color} is not valid. Please, provide valid color.`, {\n      cause: e,\n    })\n  }\n}\n\nexport const isCSSVariable = (strColor: string): boolean => /var\\(--.+\\)/.test(strColor)\nexport const cssVariableName = (colorName: string) => `--va-${kebabCase(colorName)}`\nexport const normalizeColorName = (colorName: string) => camelCase(colorName)\n\nexport const colorToRgba = (color: ColorInput, opacity: number) => {\n  return makeColor(color).setA(opacity).RGBA\n}\n\nexport const getColorLightness = (color: ColorInput) => {\n  const { R, G, B } = makeColor(color)\n  return Math.sqrt(R * R * 0.241 + G * G * 0.691 + B * B * 0.068)\n}\n\nexport const getBoxShadowColor = (color: ColorInput, opacity = 0.4) => {\n  return makeColor(color).setA(opacity).RGBA\n}\n\nexport const getBoxShadowColorFromBg = (background: ColorInput, opacity = 0.4) => {\n  return makeColor(background).setA(opacity).RGBA\n}\n\nexport const getHoverColor = (color: ColorInput, opacity = 0.2) => {\n  return makeColor(color).setA(opacity).RGBA\n}\n\nexport const getFocusColor = (color: ColorInput, opacity = 0.3) => {\n  return makeColor(color).setA(opacity).RGBA\n}\n\nexport const shiftHSLAColor = (color: ColorInput, offset: { h?: number; s?: number; l?: number; a?: number }) => {\n  const result = makeColor(color)\n\n  if (offset.h) { result.setH(result.H + offset.h) }\n\n  if (offset.s) { result.setS(result.S + offset.s) }\n\n  if (offset.l) { result.setL(result.L + offset.l) }\n\n  if (offset.a) { result.setA(result.A + offset.a) }\n\n  return result.HSLA\n}\n\nexport const setHSLAColor = (color: ColorInput, newColor: { h?: number; s?: number; l?: number; a?: number }) => {\n  const result = makeColor(color)\n\n  if (newColor.h !== undefined) { result.setH(newColor.h) }\n\n  if (newColor.s !== undefined) { result.setS(newColor.s) }\n\n  if (newColor.l !== undefined) { result.setL(newColor.l) }\n\n  if (newColor.a !== undefined) { result.setA(newColor.a) }\n\n  return result.HSLA\n}\n\n/**\n * This method guesses second color for gradient based on first one.\n * Calculation method should differ for different colors, so we split color circle\n * in zones.\n *\n * @param color\n */\nexport const shiftGradientColor = (color: ColorInput): string => {\n  const newColor = ColorTranslator.toHSLA(color, false) as HSLObject\n\n  // Gray\n  if (newColor.s < 10) {\n    return shiftHSLAColor(newColor, { h: 2, s: 5, l: 10 })\n  }\n  // Unsaturated (too pale, gray-ish, monotone)\n  // For unsaturated color, hue change does nothing.\n  if (newColor.s < 30) {\n    return shiftHSLAColor(newColor, { s: -14, l: 11 })\n  }\n  // Red\n  if ((newColor.h >= 0 && newColor.h < 44) || (newColor.h >= 285)) {\n    return shiftHSLAColor(newColor, { h: 11, s: 27, l: 8 })\n  }\n  // Yellow\n  if (newColor.h >= 44 && newColor.h < 85) {\n    return shiftHSLAColor(newColor, { h: 3, l: 9 })\n  }\n  // Green\n  if (newColor.h >= 85 && newColor.h < 165) {\n    return shiftHSLAColor(newColor, { h: 16, l: 14 })\n  }\n  // Blue\n  if (newColor.h >= 165 && newColor.h < 285) {\n    return shiftHSLAColor(newColor, { h: -15, s: 3, l: 2 })\n  }\n\n  throw new Error('This method should handle all colors. But it didn\\'t for some reason.')\n}\n\nexport const getGradientBackground = (color: string) => {\n  const colorLeft = shiftGradientColor(color)\n  const colorRight = ColorTranslator.toHSLA(color)\n\n  return `linear-gradient(to right, ${colorLeft}, ${colorRight})`\n}\n\nexport const getStateMaskGradientBackground = (color: string, maskColor: string, maskOpacity: number) => {\n  const mask = colorToRgba(maskColor, maskOpacity)\n\n  return `linear-gradient(0deg, ${mask}, ${mask}), ${color}`\n}\n\n/**\n * Check if color is valid hsl, hsla, rga, rgba or hex color\n * Taken from https://www.regextester.com/103656\n * Check options <or> isCSSVariable(prop) <or> CSS.supports('color', prop) deleted due to problems with SSR and opacity\n * Details are in the discussion: https://github.com/epicmaxco/vuestic-ui/pull/1589\n * @param strColor\n */\nexport const isColor = (strColor: string): boolean => {\n  // Need to use Regex instead of DOM methods because we support SSR\n  const cssColorRegex = /^#([\\da-f]{3}){1,2}$|^#([\\da-f]{4}){1,2}$|(rgb|hsl)a?\\((\\s*-?\\d+%?\\s*,){2}(\\s*-?\\d+%?\\s*,?\\s*\\)?)(,\\s*(0?\\.\\d+)?|1)?\\)/\n\n  return cssColorRegex.test(strColor.toLocaleLowerCase())\n}\n\nexport const applyColors = (color1: ColorInput, color2: ColorInput) => {\n  const c1 = makeColor(color1)\n  const c2 = makeColor(color2)\n  const weight = c2.A\n\n  if (weight === 1) { return c2.RGBA }\n  if (weight === 0) { return c1.RGBA }\n\n  c1.setR(Math.round((c1.R) * (1 - weight) + (c2.R) * weight))\n  c1.setG(Math.round((c1.G) * (1 - weight) + (c2.G) * weight))\n  c1.setB(Math.round((c1.B) * (1 - weight) + (c2.B) * weight))\n\n  return c1.RGBA\n}\n\nexport const isColorTransparent = (color: ColorInput) => {\n  if (!color) { return false }\n  if (color === 'transparent') { return true }\n\n  return makeColor(color).A <= 0.1\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}